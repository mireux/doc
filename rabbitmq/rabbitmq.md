# 前言

我认为RabbitMq并没有什么知识点可以单独拿出来讲，所以就直接上面试题了。可以在面试题上延申知识面。

[toc]

# RabbitMq面试题

不是很完整的，但对我来说也差不多了

## 1.消息队列的优缺点

**优点：**

既是优点，也是作用

- 解耦
- 异步
- 削峰

**缺点：**

- 降低系统的可用性。
  - 系统引入的外部依赖越多，越容易出现问题
- 系统复杂度升高。
  - 使用MQ之后需要考虑更多的问题，比如消息是否被重复消费，处理消息丢失，保证消息的传递性等一系列问题。
- 一致性问题。
  - A系统处理完直接返回，但问题是：要是 B、C、D 三个系统那里，B 和 D 两个系统写库成功了，结果 C 系统写库失败了，就造成数据不一致了。



## 2. RabbitMQ?

RabbitMQ是实现了高级消息队列协议（`AMQP`）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。相较于其他的消息队列来说，因为基于erlang开发，所以并发性能极强，性能极好，延时低，但也是因为基于erlang开发，所以rabbitmq是不可控的，很少的人掌握erlang这门语言。

## 3.AMQP是什么?

RabbitMQ就是 AMQP 协议的 `Erlang` 的实现(当然 RabbitMQ 还支持 `STOMP2`、 `MQTT3` 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。

RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相应的概念。

## 4.AMQP模型的几大组件？

- 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
- 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
- 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

## 5.说说生产者Producer和消费者Consumer?

生产者

- 消息生产者，就是投递消息的一方。
- 消息一般包含两个部分：消息体（`payload`)和标签(`Label`)。

消费者

- 消费消息，也就是接收消息的一方。
- 消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。

## 6.如何保证消息不被重复消费？或者说，如何保证消息消费的幂等性？

要保证消息不被重复消费，其实就是要保证消息消费时的幂等性。

**幂等性**： **就是用户对于同一操作发起的一次请求或者多次请求的结果是一致的，不会因为多次点击而产生了副作用。**

1. 可在内存中维护一个set，只要从消息队列里面获取到一个消息，先查询这个消息在不在set里面，如果在表示已消费过，直接丢弃；如果不在，则在消费后将其加入set当中。
2. 如何要写数据库，可以拿唯一键先去数据库查询一下，如果不存在再写，如果存在直接更新或者丢弃消息。
3. 如果是写redis那没有问题，每次都是set，天然的幂等性。
4. 让生产者发送消息时，每条消息加一个全局的唯一id，然后消费时，将该id保存到redis里面。消费时先去redis里面查一下有没有，没有再消费。
5. 数据库操作可以设置唯一键，防止重复数据的插入，这样插入只会报错而不会插入重复数据。



## 7.如何保证消息的可靠性传输？或者说，如何处理消息丢失的问题？

对于生产者而言，可以开启RabbitMq事务或者开启confirm模式。对于Mq来说，可以开启消息持久化。对于消费者来说，要关闭自动ack确认机制。改为接收到信息后手动确认。

### 生产者

1. **事务**

生产者在发送消息前开启事务，如果rabbitmq没有收到消息，那么就会返回错误信息并且回滚事务。然后尝试重新发送，直到发送成功。

```java
 channel.txSelect();//开启事物
  try{
      //发送消息
  }catch(Exection e){
      channel.txRollback()；//回滚事物
      //重新提交
  }
```

**缺点：**rabbitmq事物已开启，就会变为同步阻塞操作，生产者会阻塞等待是否发送成功，太耗性能会造成吞吐量的下降。

2. **开启confirm模式**

   在生产者中开启confirm模式之后，每次写的消息都会分配一个唯一的id，然后写入rabbitmq之中，rabbitmq会回传一个ack消息，表示这个消息是否发送完成。如果rabbitmq没能完成这个消息，会给生产者回调一个nack接口，告诉你这个消息发送失败了，你可以进行重试。而且你可以结合这个机制获取id知道是哪条信息没有发送成功。如果超过一定时间还没接收到这个消息的回调，那么你可以进行重发。

   ```java
       //开启confirm
       channel.confirm();
       //发送成功回调
       public void ack(String messageId){
         
       }
   
       // 发送失败回调
       public void nack(String messageId){
           //重发该消息
       }
   ```

**二者不同**
 事务机制是同步的，你提交了一个事物之后会阻塞住，但是confirm机制是异步的，发送消息之后可以接着发送下一个消息，然后rabbitmq会回调告知成功与否。
 一般在生产者这块避免丢失，都是用confirm机制。

### 消息队列

**消息持久化**

RabbitMQ 的消息默认存放在内存上面，如果不特别声明设置，消息不会持久化保存到硬盘上面的，如果节点重启或者意外crash掉，消息就会丢失。

所以就要对消息进行持久化处理。如何持久化，下面具体说明下：

要想做到消息持久化，必须满足以下三个条件，缺一不可。

1） Exchange 设置持久化

2）Queue 设置持久化

3）Message持久化发送：发送消息设置发送模式deliveryMode=2，代表持久化消息

而且持久化可以跟生产的confirm机制配合起来，只有消息持久化到了磁盘之后，才会通知生产者ack，这样就算是在持久化之前rabbitmq挂了，数据丢了，生产者收不到ack回调也会进行消息重发。

### 消费者

**ACK确认机制**

多个消费者同时收取消息，比如消息接收到一半的时候，一个消费者死掉了(逻辑复杂时间太长，超时了或者消费被停机或者网络断开链接)，如何保证消息不丢？

这个使用就要使用Message acknowledgment 机制，就是消费端消费完成要通知服务端，服务端才把消息从内存删除。使用rabbitmq提供的ack机制，首先关闭rabbitmq的自动ack，然后每次在确保处理完这个消息之后，在代码里手动调用ack。这样就可以避免消息还没有处理完就ack。

这样就解决了，及时一个消费者出了问题，没有同步消息给服务端，还有其他的消费端去消费，保证了消息不丢的case。

## 8.如何保证消息的顺序性

### 1.为什么要保证顺序

消息队列中的若干消息如果是对同一个数据进行操作，这些操作具有前后的关系，必须要按前后的顺序执行，否则就会造成数据异常。举例：
 比如通过mysql binlog进行两个数据库的数据同步，由于对数据库的数据操作是具有顺序性的，如果操作顺序搞反，就会造成不可估量的错误。比如数据库对一条数据依次进行了 插入->更新->删除操作，这个顺序必须是这样，如果在同步过程中，消息的顺序变成了 删除->插入->更新，那么原本应该被删除的数据，就没有被删除，造成数据的不一致问题。

### 2.为什么会出现顺序性问题

1. 一个queue，有多个consumer去消费，这样就会造成顺序的错误，consumer从MQ里面读取数据是有序的，但是每个consumer的执行时间是不固定的，无法保证先读到消息的consumer一定先完成操作，这样就会出现消息并没有按照顺序执行，造成数据顺序错误。![img](http://badwomen.asia/8494967-e450c6cb00e84866.png)
2. 一个queue对应一个consumer，但是consumer里面进行了多线程消费，这样也会造成消息消费顺序错误。

![img](http://badwomen.asia/8494967-65a77852d22d0833.png)

### 3.解决办法

拆分多个queue，每个queue一个consumer，就是多一些queue而已，确实是麻烦点；这样也会造成吞吐量下降，可以在消费者内部采用多线程的方式取消费。

或者就一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理

## 9.生产者消息运转？

1.`Producer`先连接到Broker,建立连接Connection,开启一个信道(Channel)。

2.`Producer`声明一个交换器并设置好相关属性。

3.`Producer`声明一个队列并设置好相关属性。

4.`Producer`通过路由键将交换器和队列绑定起来。

5.`Producer`发送消息到`Broker`,其中包含路由键、交换器等信息。

6.相应的交换器根据接收到的路由键查找匹配的队列。

7.如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。

8.关闭信道。

9.管理连接。

## 10.消费者接收消息过程？

1.`Producer`先连接到`Broker`,建立连接`Connection`,开启一个信道(`Channel`)。

2.向`Broker`请求消费响应的队列中消息，可能会设置响应的回调函数。

3.等待`Broker`回应并投递相应队列中的消息，接收消息。

4.消费者确认收到的消息,`ack`。

5.`RabbitMq`从队列中删除已经确定的消息。

6.关闭信道。

7.关闭连接。









# 来源

http://www.cnblogs.com/flyrock/
