# 静态代理模式

> 算是一个铺垫章节，为后面的AOP(面向切面编程)做的一个铺垫。

## 引子

倘若我们现在有一个类 其中有一个计算方法

Target类：

~~~java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Target {
    private int a;

    private int b;

    public void Calculator() {
        System.out.println(a + b);
    }
}

~~~

测试类：

```java
public class Test {

    public static void main(String[] args) {
        Target target = new Target(1,2);
        target.Calculator(); // 输出为3
    }

}
```



现在我们希望在Caculator()方法输出前后加入日志，或者输出其他文本。

- 一种是直接在业务代码中，就是我们这里的测试类中添加打印日志。

  ​	这样会造成我们核心的业务代码冗余。因为这不是必要的操作。

- 另一种就是使用代理模式

代理类：

```java
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Target {
    private int a = 0;

    private int b = 0;

    public void Calculator() {
        System.out.println(a + b);
    }
}

```



```java
public class Test {

    public static void main(String[] args) {
//        就不使用原来的类了 直接使用代理类
//        Target target = new Target(1,2);
//        target.Calculator();
        ProxyTarget proxyTarget = new ProxyTarget();
        proxyTarget.Calculator();
    }

}

```

在创建代理对象时，通过构造器塞入一个目标对象，然后在代理对象的方法内部调用目标对象同名方法，并在调用前后打印日志。也就是说，**代理对象 = 增强代码 + 目标对象（原对象）**。有了代理对象后，就不用原对象了



## 案例

可能还是有一点抽象，我们再举一个例子：

疫情期间很多公司破产，导致很多劳动者都失业了，小杰也是其中之一。公司拖欠小杰的工资一直未能下发。小杰希望通过劳动仲裁来要回属于自己的工资，所以和公司打官司。基本的仲裁步骤小杰都懂，大概有：准备劳动仲裁申请书、收集证据、提交申请、开庭答辩等等，但是小杰是第一次进行劳动仲裁，对这些具体的操作没什么经验，同时自己在这期间又有了新的工作，很难抽出时间去进行劳动仲裁。这时小杰就掏钱找了一位律师，这位**律师就相当于代理对象**。律师替小杰准备仲裁申请、提交申请、开庭后帮小杰进行辩论阐述等等，**律师不仅仅是按着仲裁需要的步骤做了，而且每一步都做的比小杰更好，这就是对被代理对象方法的增强**



- 首先定义一个接口，因为无论是小杰还是律师仲裁 流程都是一样的

```java
package Example2;

public interface ArbitrationStep {
    // 准备申请仲裁
    void prepareArb();

    // 收集证据
    void collectEvi();

    // 开庭辩论
    void debate();
}
```

- 定义一个小杰出来

  小杰类：

  ```java
  package Example2;
  
  
  public class xiaojie implements ArbitrationStep{
  
  
      @Override
      public void prepareArb() {
          System.out.println("准备仲裁申请！");
      }
  
      @Override
      public void collectEvi() {
          System.out.println("收集证据！");
      }
  
      @Override
      public void debate() {
          System.out.println("开庭答辩！");
      }
  }
  
  ```

- 小杰觉得自己辩论好像不行，需要找一个更专业的律师来帮他辩论 律师就是一个代理类

  ```java
  package Example2;
  
  public class Lawyer implements ArbitrationStep{
  
      private XiaoJie xiaoJie;
  
      public Lawyer(XiaoJie xiaoJie) {
          this.xiaoJie = xiaoJie;
      }
  
      @Override
      public void prepareArb() {
          System.out.println("律师听取小杰的想法");
          xiaoJie.prepareArb();
          System.out.println("律师对申请进行修改");
      }
  
      @Override
      public void collectEvi() {
          xiaoJie.collectEvi();
          System.out.println("律师对证据进行整理");
      }
  
      @Override
      public void debate() {
          xiaoJie.debate();
          System.out.println("律师更详细的阐述");
      }
  }
  ```

  可以看到代理类中不仅执行了被代理的方法，同时还对其方法进行了一定的增强

编写测试类

```java
package Example2;

public class Test {


    @org.junit.Test
    public void TestLawyer() {
        XiaoJie xiaoJie = new XiaoJie();
        System.out.println("小杰拜托律师进行劳动仲裁");
        Lawyer lawyer = new Lawyer(xiaoJie); // 请来了一位律师
        System.out.println("-------第一步-------");
        lawyer.prepareArb();

        System.out.println("-------第二步-------");
        lawyer.collectEvi();

        System.out.println("-------第三步-------");
        lawyer.debate();

        System.out.println("仲裁结束");
    }
}
```

![image-20211221170554961](http://badwomen.asia/image-20211221170554961.png)

**这就是静态代理。**

## 总结

通过上面的代码可以总结出静态代理的步骤

- 定义接口
  - 被代理类和代理类**都需要实现该接口**
- 定义被代理类
  - 实现上面定义的接口
- 定义代理类
  - 实现上面定义的接口
  - 创建被代理对象
    - 调用方法时需要**调用被代理对象的方法，同时自己可以对方法进行增加**

## 问题

如果一个类需要被代理，就得去创建一个代理类。如果被代理的类过多，这样就需要手动创建很多代理类。为了解决这个问题，便有了动态代理



# 动态代理模式

基于上面的问题，JDK提供了动态代理。动态代理分为两种，

- 一种是基于Java反射的动态代理。
- 一种是基于CGLib的动态代理



## 基于Java反射的动态代理

接着上面的劳动仲裁的例子，不过这次我们用动态代理去实现

**但是需要用到Proxy类的两个静态方法**

- **getProxyClass**
  - 这个方法， 会从你传入的接口Class中，“拷贝”类结构信息到一个新的Class对象中，但**新的Class对象带有构造器，是可以创建对象的**
- **newProxyInstance**（一般直接用这个）
  - 封装了得到代理类Class对象、构造函数等细节，直接返回了代理对象

**接口和被代理类不变**

```java
package Example3;
public interface ArbitrationStep {
    // 准备申请仲裁
    void prepareArb();

    // 收集证据
    void collectEvi();

    // 开庭辩论
    void debate();
}
```

```java
package Example3;
import Example2.ArbitrationStep;

public class XiaoJie implements ArbitrationStep {


    @Override
    public void prepareArb() {
        System.out.println("准备仲裁申请！");
    }

    @Override
    public void collectEvi() {
        System.out.println("收集证据！");
    }

    @Override
    public void debate() {
        System.out.println("开庭答辩！");
    }
}
```

### **通过反射获得代理对象**

```java
package Example4;

import java.lang.reflect.*;

public class Tribunal2 {
    public static void main(String[] args) throws NoSuchMethodException, InvocationTargetException, InstantiationException,
    IllegalAccessException {
        // 获取代理类的class对象
        Class<?> proxyClazz = Proxy.getProxyClass(ArbitrationStep.class.getClassLoader(), ArbitrationStep.class);

        // 获取构造函数
        Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);

        // 创建代理对象
        ArbitrationStep lawyerProxy = (ArbitrationStep) constructor.newInstance(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                // 创建被代理对象，用于调用方法
                XiaoJie xiaoJie = new XiaoJie();

                // 通过invoke方法调用了被代理对象的方法
                Object invoke = method.invoke(xiaoJie, args);

                // 每个步骤都让律师帮忙处理
                System.out.println("律师帮忙处理！");
                return invoke;
            }
        });
        // 通过代理对象调用方法
        System.out.println("-------第一步-------");
        lawyerProxy.prepareArb();

        System.out.println("-------第二步-------");
        lawyerProxy.collectEvi();

        System.out.println("-------第三步-------");
        lawyerProxy.debate();
        System.out.println();
    }
}
```

![image-20211221233348314](http://badwomen.asia/image-20211221233348314.png)



>  getProxyClass源码：

```java
@Deprecated
@CallerSensitive
public static Class<?> getProxyClass(ClassLoader loader,
                                     Class<?>... interfaces)
    throws IllegalArgumentException
{
    Class<?> caller = System.getSecurityManager() == null
                          ? null
                          : Reflection.getCallerClass();

    return getProxyConstructor(caller, loader, interfaces)
        .getDeclaringClass();
}
```





### 自己封装获得代理对象的方法



```java
package Example4;

import java.lang.reflect.*;

public class Tribunal3 {

    public static void main(String[] args) throws InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException {
        XiaoJie xiaoJie = new XiaoJie();
        ArbitrationStep lawyerProxy = (ArbitrationStep) getProxy(xiaoJie);
        // 通过代理对象调用方法
        System.out.println("-------第一步-------");
        lawyerProxy.prepareArb();

        System.out.println("-------第二步-------");
        lawyerProxy.collectEvi();

        System.out.println("-------第三步-------");
        lawyerProxy.debate();
        System.out.println();
    }


    public static Object getProxy(Object target) throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException {
        // target为被代理对象，得到其代理类的Class对象
        Class<?> proxyClass = Proxy.getProxyClass(target.getClass().getClassLoader(), target.getClass().getInterfaces());
        // 获得构造函数
        Constructor<?> constructor = proxyClass.getConstructor(InvocationHandler.class);

        // 获得代理对象
        return constructor.newInstance(new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                if(method.getName().equals("collectEvi")) {
                    System.out.println("律师处理证据");
                }
                Object invoke = method.invoke(target, args);
                System.out.println("代理增强类");
                return invoke;
            }
        });


    }
}

```

> 将获取代理对象的过程抽象出来



![image-20211221233537692](http://badwomen.asia/image-20211221233537692.png)



### **通过newProxyInstance()获得代理对象**

替换getProxy(Object target)中的方法即可

```java
package Example4;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class Tribunal4 {

    public static void main(String[] args) {
        XiaoJie xiaoJie = new XiaoJie();
        ArbitrationStep lawyerProxy = (ArbitrationStep) getProxyByProxyMethod(xiaoJie);

        // 通过代理对象调用方法
        System.out.println("-------第一步-------");
        lawyerProxy.prepareArb();

        System.out.println("-------第二步-------");
        lawyerProxy.collectEvi();

        System.out.println("-------第三步-------");
        lawyerProxy.debate();
        System.out.println();
    }




    public static Object getProxyByProxyMethod(Object target) {
        // 直接返回代理对象
        return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                Object invoke = method.invoke(target, args);
                System.out.println("代理对象增强方法");
                return invoke;
            }
        });
    }
}
```

![image-20211221233910231](http://badwomen.asia/image-20211221233910231.png)

#### **newProxyInstance** 帮我们做了什么事情

> newProxyInstance 部分源码 JDK11

```java
@CallerSensitive
public static Object newProxyInstance(ClassLoader loader,
                                      Class<?>[] interfaces,
                                      InvocationHandler h) {
    // 判断传入的InvocationHandler是否为null 如果为null抛出异常
    Objects.requireNonNull(h);

    // 下面这一段其实就是getProxyClass方法的内部实现 所以我特意把getProxyClass内部出现写在前面
    // ---------------------------------------------------------------------------
    final Class<?> caller = System.getSecurityManager() == null
                                ? null
                                : Reflection.getCallerClass();

    /*
     * Look up or generate the designated proxy class and its constructor.
     * 查找或生成指定的代理类及其构造函数
     */
    Constructor<?> cons = getProxyConstructor(caller, loader, interfaces);

    return newProxyInstance(caller, cons, h);
}

private static Object newProxyInstance(Class<?> caller, // null if no SecurityManager
                                       Constructor<?> cons,
                                       InvocationHandler h) {
    /*
     * Invoke its constructor with the designated invocation handler.
     * 使用指定的调用处理程序调用其构造函数。
     */
    try {
        if (caller != null) {
            checkNewProxyPermission(caller, cons.getDeclaringClass());
        }

        return cons.newInstance(new Object[]{h});
    } catch (IllegalAccessException | InstantiationException e) {
        throw new InternalError(e.toString(), e);
    } catch (InvocationTargetException e) {
        Throwable t = e.getCause();
        if (t instanceof RuntimeException) {
            throw (RuntimeException) t;
        } else {
            throw new InternalError(t.toString(), t);
        }
    }
}
```

我们自己获取代理对象的步骤是

- 通过**getProxyClass**获得**代理对象的Class对象**（接口+对应的构造函数）
- 通过Class对象调用得到构造方法
- 通过构造方法去创建实例
  - 构造方法传入InvocationHandler实例，需要实现其invoke方法

newProxyInstance帮我们获取代理的步骤和上面类似，只不过Class对象是直接通过**getProxyConstructor(caller, loader, interfaces); **来获取的。而我们自己封装的代码中，使用的是getProxyClass方法。但是该方法最终还是调用的getProxyConstructor(caller, loader, interfaces)来获取的Class对象

## 如何实现方法增强

上面的例子确实将被代理对象的方法增强了，但这是如何实现的呢

### InvocationHandler

我们在获得代理类构造器的时候，传入了InvocationHandler

```java
Constructor<?> constructor = proxyClazz.getConstructor(InvocationHandler.class);
```

InvocationHandler是一个**接口，内部只有一个方法invoke**

```java
public interface InvocationHandler {
    // 中间还有一大段注释
 public Object invoke(Object proxy, Method method, Object[] args)
        throws Throwable;
}
```

在通过constructor获取代理对象时，newInstance方法需要传入一个invocationHandler的实例，这个实例重写了invoke方法，就是**通过它代理对象增强了被代理对象的方法**



![img](http://badwomen.asia/20201013160426.png)

其实是类似于静态代理的，只不过帮你封装了一个InvocationHandler类。

### **总结**

调用代理对象的方法时，**实际上调用的是InvocationHandler的invoke方法**，这个方法内部不仅调用了被代理对象的方法，还可以增加其他功能

## 为什么必须实现接口

通过

```java
lawyerProxy.getClass().getSuperclass()
```

可以获得代理对象的父类，可以看到其父类为

![image-20211221235900389](http://badwomen.asia/image-20211221235900389.png)

也就是无论是什么**代理类，都会继承自Proxy**，而Java又是**单继承**的，所以想要被代理对象与代理对象产生联系，就只能通过接口来实现了，而且可以保证代理类只是用来增强被代理类的。





# 基于CGLib的动态代理

Java动态代理是**面向接口**的代理模式，如果没有接口，但是想要去实现动态代理，就需要用到CGLib来进行动态代理了

CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展Java类

被代理类：

```java
package CGLib;


import Example4.ArbitrationStep;

public class XiaoJie implements ArbitrationStep {


    @Override
    public void prepareArb() {
        System.out.println("准备仲裁申请！");
    }

    @Override
    public void collectEvi() {
        System.out.println("收集证据！");
    }
    
    @Override
    public void debate() {
        System.out.println("开庭答辩！");
    }
}
```



使用CGLib需要先导第三方jar包：

~~~xml
            <dependency>
                <groupId>cglib</groupId>
                <artifactId>cglib</artifactId>
                <version>3.3.0</version>
            </dependency>
~~~

**自定义拦截器实现MethodInterceptor接口**

LawyerInterceptor类：

~~~java
package CGLib;

import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class LawyerInterceptor implements MethodInterceptor {
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        // 前置增强
        System.out.println("律师给出建议");
        // 被代理类执行的方法（被增强的方法）
        // 注意这里是调用invokeSuper而不是invoke，否则死循环;
        // methodProxy.invokeSuper执行的是原始类的方法;
        // method.invoke执行的是子类的方法;
        Object invoke = methodProxy.invokeSuper(o, objects);
        
        // 后置增强
        System.out.println("律师帮忙");
        return invoke;
    }
}

~~~

**使用Enhancer创建代理对象**

```java
package CGLib;

import net.sf.cglib.proxy.Enhancer;

public class main {

    public static void main(String[] args) {
        // 创建增强器
        Enhancer enhancer = new Enhancer();

        // 传入被代理的class (作为代理对象的父类)
        enhancer.setSuperclass(XiaoJie.class);

        // 设置回调函数，传入自定义的拦截器
        enhancer.setCallback(new LawyerInterceptor());

        // 获取代理对象
        XiaoJie proxy = (XiaoJie) enhancer.create();

        System.out.println("小杰委托律师帮忙进行劳动仲裁");
        System.out.println("-------第一步-------");
        proxy.prepareArb();

        System.out.println("-------第二步-------");
        proxy.collectEvi();

        System.out.println("-------第三步-------");
        proxy.debate();
        System.out.println();
        
        System.out.println("仲裁结束");
    }
}
```

![image-20211222141753982](http://badwomen.asia/image-20211222141753982.png)

## CGLib实现原理

CGLib可以为没有实现接口的类创建代理类。其原理是CGLib底层使用了ASM框架，该框架可以通过修改字节码，来创建一个被代理类的子类，也就是代理类。并在子类中采用方法拦截的技术**拦截所有父类方法的调用，顺势织入横切逻辑**。这种思想符合**里氏替换原则**，即子类可以扩展父类的功能，但是不能改变父类原有的功能。

### 代理类的父类

就上面的例子，我们通过

```
proxy.getClass()
proxy.getClass().getSuperclass();
```

来获取代理类的父类，可以看到其父类是

```
class CGLib.XiaoJie$$EnhancerByCGLIB$$80107bc2
class CGLib.XiaoJie
```

也就是我们的被代理类，这也从一定程度上说明自定义拦截器在调用被拦截对象的方法时，需要调用

```
Object invoke = methodProxy.invokeSuper(o, objects);
```



# 参考来源

https://nyimac.gitee.io/2020/11/03/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/

