# Mysql 面试题

> mysql 还是选择以面试题的形式去复习。CRUD语句没什么复习的必要，剩下的也就是背了……

# 目录

- 事务的四大特性？

- 事务隔离级别有哪些？

- 索引

- - 什么是索引？
  - 索引的优缺点？
  - 索引的作用？
  - 什么情况下需要建索引？
  - 什么情况下不建索引？
  - 索引的数据结构
  - Hash索引和B+树索引的区别？
  - 为什么B+树比B树更适合实现数据库索引？
  - 索引有什么分类？
  - 什么是最左匹配原则？
  - 什么是聚集索引？
  - 什么是覆盖索引？
  - 索引的设计原则？
  - 索引什么时候会失效？
  - 什么是前缀索引？

- 常见的存储引擎有哪些？

- MyISAM和InnoDB的区别？

- MVCC 实现原理？

- 快照读和当前读

- 共享锁和排他锁

- bin log/redo log/undo log

- bin log和redo log有什么区别？

- 讲一下MySQL架构？

- 查询语句执行流程？

- 更新语句执行过程？

- truncate、delete与drop区别？

- having和where的区别？

- 什么是MySQL主从同步？

- 为什么要做主从同步？

- 乐观锁和悲观锁是什么？


## 事务的四大特性？

事务的特性：ACID。原子性、一致性、隔离性、持久性。

- **原子性**：指事务所包含的所有操作，要么全部成功，要么全部失败回滚。

- **一致性**：是指一个事务执行之前和执行之后都必须处于一致性的状态。比如a与b账户共有1000块，两人之间转账之后无论成功还是失败，它们的账户总和还是1000。总之可以理解为：一致性是为了保护数据的完整性。
- **隔离性**：隔离性是指当多个用户并发操作数据库，比如操作同一张表，数据库为每一个用户开启的事务，不能被其他的事务所干扰或者影响，事务之间是彼此独立的。
- **持久性**：永久性是指一个事务一旦提交了，那么对数据库中数据的改变就是永久的，即使是在数据库发生故障时，也不会丢失事务提交的数据。

## 事务的隔离级别

先了解下几个概念：脏读、不可重复读、幻读。

**脏读：**是指在一个事务中读取了另一个未提交的事务中的数据

**不可重复读：**在对于数据库的某行记录，一个事务范围内进行多次查询却返回了不同的数据值，这是由于在查询间隔，另一个事务修改了数据并提交了。

**幻读：**当事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录值，当之前的事务再次读取该范围的记录时，会产生幻行，就像产生幻觉一样。关于幻读可以参考文章：

[https://zhuanlan.zhihu.com/p/103580034]: https://zhuanlan.zhihu.com/p/103580034	"面试官一上来就问Mysql：幻读到底是什么？"

**不可重复读和脏读的区别**是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

**幻读和不可重复读**都是读取了另一条已经提交的事务，不同的是不可重复读的重点是修改，幻读的重点在于新增或者删除。



事务隔离就是为了解决上面提到的脏读、不可重复读、幻读这几个问题。

MySQL数据库为我们提供的四种隔离级别：

- **Serializable** (串行化)：通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
- **Repeatable read** (可重复读)：MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。
- **Read committed** (读已提交)：一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
- **Read uncommitted** (读未提交)：所有事务都可以看到其他未提交事务的执行结果。

## 什么是索引？

索引是存储引擎用于提高数据库表的访问速度的一种**数据结构**。

## 索引的优缺点？

**优点：**

- **加快数据查找的速度**
- 为用来排序或者是分组的字段添加索引，可以**加快分组和排序的速度**
- **加快表与表之间连接的速度**

**缺点：**

- 建立索引需要**占用物理空间**
- 会降低表的增删改的效率，因为每次对表记录进行增删改，需要进行**动态维护索引**，导致增删改时间变长

## 索引的作用？

**作用**：可以快速的查询数据库中的特定信息。数据时存储在硬盘上的，查询数据时，如果没有索引，将会加载所有的数据到内存，依次进行检索，读取磁盘较多次数。有了索引，就不需要加载所有数据，因为B+tree一般高度都在2-4层，只需要读取2-4次磁盘，查询作用大大提升。

## 什么情况下需要建索引？

1. 经常用于查询的字段
2. 经常用于连接的字段建立索引，可以加快连接速度。
3. 经常需要排序的字段建立索引，因为索引已经是排序的了，可以加快排序查询速度

## 什么情况下不建索引？

1. `where`条件中用不到的字段不适合建立索引
2. 表记录较少
3. 需要经常增删改
4. **参与列计算**的列不适合建索引
5. **区分度不高**的字段不适合建立索引，如性别等

## 索引的数据结构

索引的数据结构一般是两种，B+树或者哈希表。对应的索引分别是B+索引和哈希索引。InnoDB引擎的索引类型是B+树索引，默认的索引类型为B+树索引。InnoDB是支持哈希索引的，但是它支持的哈希索引是自适应的，InnoDB引擎会根据表的使用情况自动生成哈希索引，不能人为的干预是否在一张表中生成哈希索引。简而言之，就是**InnoDB用户无法手动创建哈希索引，如果判定建立自适应哈希索引，那么自己会建立相关哈希索引**。这里详细讲解一下B+树。

### B+树

[B+树]: https://www.cnblogs.com/lianzhilei/p/11250589.html	"B+树"

> 后面可能会单独出一篇将B树和B+树

## Hash索引和B+树索引的区别？

- 哈希索引**不支持排序**，因为哈希是无序的
- 哈希索引**不支持范围查找**
- 哈希索引**不支持模糊查询**以及多列索引的**最左匹配原则**
- 因为哈希表中会**存在哈希冲突**，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点。

## 什么是最左前缀匹配原则？

如果 SQL 语句中用到了组合索引中的最左边的索引，那么这条 SQL 语句就可以利用这个组合索引去进行匹配。当遇到范围查询(`>`、`<`、`between`、`like`)就会停止匹配，后面的字段不会用到索引。

举个例子：

对`(a,b,c)`建立索引，查询条件使用 a/ab/abc 会走索引，使用 bc 不会走索引。如果查询条件为`a = 1 and b > 2 and c = 3`，那么a、b个字两段能用到索引，而c无法使用索引，因为b字段是范围查询，导致后面的字段无法使用索引。

> 这里有好多东西要说 后面单开一篇文章

## 什么是覆盖索引？

`select`的数据列只用从索引中就能够取得，不需要**回表**进行二次查询，也就是说查询列要被所使用的索引覆盖。对于`innodb`表的二级索引，如果索引能覆盖到查询的列，那么就可以避免对主键索引的二次查询。

不是所有类型的索引都可以成为覆盖索引。覆盖索引要存储索引列的值，而哈希索引、全文索引不存储索引列的值，所以MySQL使用b+树索引做覆盖索引。

对于使用了覆盖索引的查询，在查询前面使用`explain`，输出的extra列会显示为`using index`。

> 后面和最左前缀匹配原则放一起细讲

## 索引有什么分类？

1、**主键索引**：名为primary的唯一非空索引，不允许有空值。

2、**唯一索引**：索引列中的值必须是唯一的，但是允许为空值。唯一索引和主键索引的区别是：唯一约束的列可以为`null`且可以存在多个`null`值。唯一索引的用途：唯一标识数据库表中的每条记录，主要是用来防止数据重复插入。

3、**组合索引**：在表中的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时，索引才会被使用，使用组合索引时需遵循最左前缀原则。

4、**全文索引**：只有在`MyISAM`引擎上才能使用，只能在`CHAR`、`VARCHAR`和`TEXT`类型字段上使用全文索引。

## 什么是聚簇索引？

- 聚簇索引： 将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据
- 非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

对于`InnoDB`来说，聚集索引一般是表中的主键索引，如果表中没有显示指定主键，则会选择表中的第一个不允许为`NULL`的唯一索引。如果没有主键也没有合适的唯一索引，那么`InnoDB`内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键长度为6个字节，它的值会随着数据的插入自增。

## 索引的设计原则？

- 索引列的**区分度越高**，索引的效果越好。比如使用性别这种区分度很低的列作为索引，效果就会很差。
- 尽量使用**短索引**，对于较长的字符串进行索引时应该指定一个较短的前缀长度，因为较小的索引涉及到的磁盘I/O较少，查询速度更快。
- 索引不是越多越好，每个索引都需要额外的物理空间，维护也需要花费时间。
- 利用**最左前缀原则**。

## 索引什么时候会失效？

导致索引失效的情况：

- 对于组合索引，不是使用组合索引最左边的字段，则不会使用索引(最左前缀匹配原则)
- 以%开头的like查询如`%abc`，无法使用索引；非%开头的like查询如`abc%`，相当于范围查询，会使用索引
- 查询条件中列类型是字符串，没有使用引号，可能会因为类型不同发生隐式转换，使索引失效
- 判断索引列是否不等于某个值时
- 对索引列进行运算
- 查询条件使用`or`连接，也会导致索引失效

## 什么是前缀索引？

有时需要在很长的字符列上创建索引，这会造成索引特别大且慢。使用前缀索引可以避免这个问题。

前缀索引是指对文本或者字符串的前几个字符建立索引，这样索引的长度更短，查询速度更快。

创建前缀索引的关键在于选择足够长的前缀以**保证较高的索引选择性**。索引选择性越高查询效率就越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的数据行。

~~~sql
// email列创建前缀索引
ALTER TABLE table_name ADD KEY(column_name(prefix_length));
~~~

## 常见的存储引擎有哪些？

MySQL中常用的四种存储引擎分别是：**MyISAM**、**InnoDB**、**MEMORY**、**ARCHIVE**。MySQL 5.5版本后默认的存储引擎为`InnoDB`。

- **InnoDB引擎：**

  InnoDB是Mysql默认的事务性存储引擎。使用最广泛，基于聚簇索引建立的。（InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。）

  **优点**：支持事务和崩溃修复能力；引入了行级锁和外键约束。

  **缺点**：占用的数据空间相对较大。

  **适用场景**：需要事务支持，并且有较高的并发读写频率。

- **MyISAM引擎：**

  数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，可以使用MyISAM引擎。MyISAM会将表存储在两个文件中，数据文件`.MYD`和索引文件`.MYI`。

  **优点**：访问速度快。

  **缺点**：MyISAM不支持事务和行级锁，不支持崩溃后的安全恢复，也不支持外键。

  **适用场景**：对事务完整性没有要求；表的数据都会只读的。

## MyISAM和InnoDB的区别？

1. **是否支持行级锁：**MyISAM只有表级锁，而InnoDB支持行级锁和表级锁，默认为行级锁。
2. **是否支持事务和崩溃后的安全修复：**MyISAM不提供事务支持。而InnoDB提供事务支持，具有事务、回滚和崩溃修复能力。
3. **是否支持外键：**InnDB支持外键，MyISAM不支持。
4. **是否支持MVCC： **MyISAM不支持，InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效。
5. MyISAM是非聚簇索引，InnoDB是聚簇索引。

## MVCC 实现原理？

MVCC(`Multiversion concurrency control`) 就是同一份数据保留多版本的一种方式，进而实现并发控制。在查询的时候，通过`read view`和版本链找到对应版本的数据。

作用：提升并发性能。对于高并发场景，MVCC比行级锁开销更小。

mvcc实现原理：https://www.cnblogs.com/JCpeng/p/15195149.html

锁机制：https://mp.weixin.qq.com/s?__biz=MzIzNjg4OTcyNA==&mid=2247483797&idx=1&sn=020cc8c6f9fecee01c07500225aea77d&scene=21#wechat_redirect

## 快照读和当前读

**快照读：**读取的是快照的版本。普通的SELECT就是快照读。通过mvcc来进行并发控制，不需要加锁。

**当前读：**读取的是最新版本。`UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE`是当前读。

快照读情况下，InnoDB通过`mvcc`机制避免了幻读现象。而`mvcc`机制无法避免当前读情况下出现的幻读现象。因为当前读每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。

**那么MySQL是如何避免幻读？**

- 在快照读情况下，MySQL通过`mvcc`来避免幻读。
- 在当前读情况下，MySQL通过`next-key`来避免幻读（加行锁和间隙锁来实现的）。

next-key包括两部分：行锁和间隙锁。行锁是加在索引上的锁，间隙锁是加在索引之间的。

`Serializable`隔离级别也可以避免幻读，会锁住整张表，并发性极低，一般不会使用。

## 共享锁和排他锁

SELECT 的读取锁定主要分为两种方式：共享锁和排他锁。

```sql
select * from table where id<6 lock in share mode; --共享锁
select * from table where id<6 for update; --排他锁
```

这两种方式主要的不同在于`LOCK IN SHARE MODE`多个事务同时更新同一个表单时很容易造成死锁。

申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。在进行事务操作时，MySQL会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被`commit`语句或`rollback`语句结束为止。

`SELECT... FOR UPDATE` 使用注意事项：

1. `for update` 仅适用于innodb，且必须在事务范围内才能生效。
2. 根据主键进行查询，查询条件为`like`或者不等于，主键字段产生**表锁**。
3. 根据非索引字段进行查询，会产生**表锁**。

## bin log/redo log/undo log

MySQL的日志主要包括二进制日志、查询日志、慢查询日志、事务日志、错误日志。其中比较重要的是bin log（二进制日志）、redo log（重做日志）、undo log（回滚日志）。

**bin log：**

​	bin log是MySQL数据库级别的文件，记录对MySQL数据库执行修改的所有操作，不会记录select和show语句。主要用于恢复数据库和同步数据库。

**redo log:**

​	redo log是innodb引擎级别的，用来记录innodb存储引擎的事务日志，不管事务是否提交都会记录下来，用于数据恢复。当数据库发生故障时，innodb引擎会使用redo log恢复到发生故障前的时刻，以此来保证数据的完整性。

**undo log:**

​	除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于数据的撤回操作，它保留了记录修改前的数据。通过undo log可以实现事务回滚，回溯到某个特定的版本的数据，实现**MVCC**。

## bin log和redo log有什么区别？

1. bin log会记录所有日志记录，包括innodb和MyISAM等引擎的日志；redo log只会记录InnoDB引擎自身的记录。

2. bin log只有在事务提交前写入磁盘，一个事务只写一次；而在事务过程中，redo log不断写入磁盘。

3. bin log是逻辑日志，记录的是sql语句的原始逻辑；redo log是物理日志，记录的是在某个数据页上做了什么修改。

   bin log 是可以追加写入的。“追加写” 是指 bin log 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。redo log 是循环写的，空间固定会被用完。而 bin log 是追加日志，保存的是全量的日志。这就会导致一个问题，那就是没有标志能让 InnoDB 从 bin log 中判断哪些数据已经刷入磁盘了，哪些数据还没有。

   举个例子，bin log 记录了两条日志：

   ```markdown
   记录 1：给 id = 1 这一行的 age 字段加 1
   记录 2：给 id = 1 这一行的 age 字段加 1
   ```

   假设在记录 1 刷盘后，记录 2 未刷盘时，数据库崩溃。重启后，只通过 bin log 数据库是无法判断这两条记录哪条已经写入磁盘，哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 id = 1 这行数据来说，都是不对的。

   但 redo log 不一样，只要刷入磁盘的数据，都会从 redo log 中被抹掉，数据库重启后，直接把 redo log 中的数据都恢复至内存就可以了。

   这就是为什么说 redo log 具有崩溃恢复的能力，而 bin log 不具备。

## 讲一下MySQL架构？

![图片](http://badwomen.asia/640)

MySQL主要分为Service层和存储引擎层：

- **Service层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都是在这一层实现的。比如存储过程，触发器，视图，函数等，还有一个通用的日志模块binlog日志模块。
- 存储引擎：主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。

**Server 层基本组件**

- **连接器：** 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。
- **查询缓存:** 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。
- **分析器:** 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。
- **优化器：** 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。
- **执行器：** 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。

## 查询语句执行流程？

查询语句的执行流程如下：权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。

![图片](http://badwomen.asia/640)

1. MySQL 客户端与服务器间建立连接，客户端发送一条查询给服务器；
2. 服务器先检查查询缓存，如果命中了缓存，则立刻返回存储在缓存中的结果；否则进入下一阶段；
3. 服务器端进行 SQL 解析、预处理，生成合法的解析树；
4. 再由优化器生成对应的执行计划；
5. 执行器根据优化器生成的执行计划，调用相应的存储引擎的 API 来执行，并将执行结果返回给客户端

## 更新语句执行过程？（https://mp.weixin.qq.com/s/4nIYKZ47817X00B4rRvo7g）

这个也有其他的问法，比如：如何解决bin log、redo log的一致性问题？或者是让你描述一下bin log/redo log的两提交原理。 

![图片](http://badwomen.asia/640)

可以看到，**所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit**。

根据两阶段提交，**崩溃恢复时的判断规则**是这样的：

1. 如果 redo log 里面的事务是完整的，也就是已经有了 commit 标识，则直接提交
2. 如果 redo log 里面的事务处于 prepare 状态，则判断对应的事务 binlog 是否存在并完整

- a. 如果 binlog 存在并完整，则提交事务；
- b. 否则，回滚事务。

~~~markdown
所谓两阶段提交，其实就是把 redo log 的写入拆分成了两个步骤：prepare 和 commit。

首先，存储引擎将执行更新好的新数据存到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务

然后执行器生成这个操作的 bin log，并把 bin log 写入磁盘

最后执行器调用存储引擎的提交事务接口，存储引擎把刚刚写入的 redo log 状态改成提交（commit）状态，更新完成


如果数据库在写入 redo log(prepare) 阶段之后、写入 binlog 之前，发生了崩溃：

此时 redo log 里面的事务处于 prepare 状态，binlog 还没写，之后从库进行同步的时候，无法执行这个操作，但是实际上主库已经完成了这个操作，所以为了主备一致，MySQL 崩溃时会在主库上回滚这个事务

而如果数据库在写入 binlog 之后，redo log 状态修改为 commit 前发生崩溃，此时 redo log 里面的事务仍然是 prepare 状态，binlog 存在并完整，这样之后就会被从库同步过去，但是实际上主库并没有完成这个操作，所以为了主备一致，即使在这个时刻数据库崩溃了，主库上事务仍然会被正常提交。
~~~



## truncate、delete与drop区别？

**相同点：**

1. `truncate`和不带`where`子句的`delete`、以及`drop`都会删除表内的数据。
2. `drop`、`truncate`都是`DDL`语句（数据定义语言），执行后会自动提交。

**不同点：**

1. truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引；
2. 一般来说，执行速度: drop > truncate > delete。

## having和where的区别？

- 二者作用的对象不同，`where`子句作用于表和视图，`having`作用于组。
- `where`在数据分组前进行过滤，`having`在数据分组后进行过滤。

## 什么是MySQL主从同步？

主从同步使得数据可以从一个数据库服务器复制到其他服务器上，在复制数据时，一个服务器充当主服务器（`master`），其余的服务器充当从服务器（`slave`）。

因为复制是异步进行的，所以从服务器不需要一直连接着主服务器，从服务器甚至可以通过拨号断断续续地连接主服务器。通过配置文件，可以指定复制所有的数据库，某个数据库，甚至是某个数据库上的某个表。

## 为什么要做主从同步？

1. 读写分离，使数据库能支撑更大的并发。
2. 在主服务器上生成实时数据，而在从服务器上分析这些数据，从而提高主服务器的性能。
3. 数据备份，保证数据的安全。

## 乐观锁和悲观锁是什么？

数据库中的并发控制是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观锁和悲观锁是并发控制主要采用的技术手段。

- 悲观锁就是悲观的认为每次修改都会发生并发冲突，所以每次进行任何操作都要上锁。在它释放锁之前任何人都不能对其数据进行操作，直到前面一个人把锁释放后下一个人数据加锁才可对数据进行加锁。
- 乐观锁就是乐观的认为每次修改不会发生并发冲突，只有在最后的时候会去检查数据是否被修改过。一般通过版本号或者CAS进行检查。

